Wilma Example - Short Circuit
=============================

Purpose of this example
---------------------------------------
First of all, this is a very complex example, uses almost all features and extension points of Wilma.
If you just start with the examples, don't start with this one, as this is - again - a complex one.

Short Circuit is a tool that collects responses for specific requests, and as soon as the response is available, next time,
when the same request arrives, Wilma will use a "short circuit", and instead of acting as proxy, as the answer is known,
Wilma will act as stub and sends the preserved answer back. To store the responses, this Wilma plugin has an internal (very basic) cache.

What is more, by using the External Service feature of Wilma, this plugin implements an external service, and with this service,
it is possible to check what is in the internal cache.

As an extra bonus, the internal content cache can be saved to disk, and any time later, it can be loaded.

Do you know why it is good? Yes, you may record the traffic, and use it later to stub the traffic, as necessary.

Please note that right now this example caches only responses, those have status code 200,
and the response Content-type is any of the followings: "text/plain", "application/json", "text/html" and "text/css".

Implementation
---------------------------------------
Now let's see how it works.

First of all the `ShortCircuitInterceptor` class uses 3 extension points of Wilma: `RequestInterceptor`, `ResponseInterceptor` and `ExternalWilmaService`.

+ `RequestInterceptor` - marks all incoming request with a special header. The same requests will get the same special header.
With this extra header, Short Circuit can identify equal requests, and can identify entries in the cache.
+ `ResponseInterceptor` - checks if the response need to be cached or not, and if so, checks if it was already preserved or not, and if so - saves the response in the cache.
As soon as an answer is preserved in the cache, next time the response can be generated by the stub (this is the Short Circuit).
+ `ExternalWilmaInterface` - to implement this interface you need to implement two methods. The first (`getHandlers`) tells Wilma, what kind of external services are offered by the plug-in.
In our case, the Short Circuit will provide REST interface to the cache at `<standardExternalServiceUrl>/circuits` URL. The second method (`handleRequest`) is the entry point of the REST service.
The majority of the REST service, including save and load of the cache, is implemented in the `ShortCircuitInterceptorCore` class.

The next important part is the cache, that is a HashMap. The key in the map is the content of the extra header, generated by the `RequestInterceptor`.
The value contains all the necessary information when a message should be generated by the stub,
the structure of the value is implemented in `ShortCircuitResponseInformation`.

Of course, when a request arrives, somehow we should decide if it should be forwarded to the original target,
or we have the proper response already in the cache, and therefore a stub answer should be generated.
This task is done by the `ShortCircuitChecker` class, that implements Wilma's `ConditionChecker` interface. What its `checkCondition` method do?
It determines if the request and its response are cached already or not, and
+ If the request is cached and the response is available already, then returns true (need to be stubbed).
+ Any other case, returns with false (just let the request go through) but ensures that at least the request is cached,
giving the possibility to the `ResponseInterceptor` to preserve the answer as soon as it arrives.

The last implementation part is the `ShortCircuitResponseGenerator` that generates an empty response first (see `TemplateGenerator` interface implementation)
and the fills the response properly from the cache (see `TemplateFormatter` interface implementation).

The final part is the stub configuration file that connects all the things together. It can be found in `src/main/java/resources` folder.
Its condition-descriptor part contains 2 conditions connected with AND logic:
* the first condition is to choose the targets those will be used in the cache. As you can check, both http:// and https:// calls will be cached, but here you may specify additional path too
* the second condition is the `ShortCircuitChecker` class, and its job already described above.
Its response descriptor part ensures that the `ShortCircuitResponseGenerator` class will generate and format the content of the stub answer, when it is necessary.
Its interceptor descriptor part ensures that `ShortCircuitInterceptor` is called when either request or response arrives to Wilma.

Important Settings
---------------------------------------
Don't forget to **enable** the interceptors! Without that, the Short Circuit won't work properly (no message will be cached at all).

REST Interface of Short Circuit plugin
---------------------------------------
Note: In order to list the available services, use this call:
```
GET or POST http://localhost:1234/config/public/services/
```
See more information on using external service calls from Wilma plugins [here](https://github.com/epam/Wilma/wiki/Service-extensions-in-Plugins).
Also, in the examples below, it is assumed that the default configuration is in use and Wilma is used on `localhost`,
therefore the Wilma `<standardExternalServiceUrl>` is: `http://localhost:1234/config/public/services/`.

Get the internal cache content
---
Gets the list of the captured requests and information whether the response is captured or not.
If the same request arrives and the response is captured already,
the relevant cached message will be sent back by the stub.
```
GET http://localhost:1234/config/public/services/ShortCircuitInterceptor/circuits 
```

The list is presented as an array of key-value pairs, 
where the key is an unique id - the entry of the cache -, meanwhile the value is a hash-key to identify the request.
In the Short Circuit logic, this hash-key is used to identify the cached response too.

Clean-up the cache
------------------
You may clean-up (delete) the cache by calling the Short Circuit URL with DELETE method

So just call this:
```
DELETE http://localhost:1234/config/public/services/ShortCircuitInterceptor/circuits
```
and the cache will be empty - that means all the preserved and cached response will be forgotten.

The call will response with the actual (empty) map.

Delete one specific entry from the cache
--------------------------
To delete a specific cache entry, call this:
```
DELETE http://localhost:1234/config/public/services/ShortCircuitInterceptor/circuits?id={idInShortCircuitCache}
```

*Note: By calling the targets through Wilma, and with the two delete functions described above, you may prepare a cache content that you might preserve and use later.
To fulfill such need, the cache content (at least those have valid and usable responses already), can be saved and later loaded back.
See below how:*

Save the actual cache into a folder
-----------------------------------
You may save the actual internal Short Circuit cache onto the disk.
Just specify a folder name in the following request:

```
POST http://localhost:1234/config/public/services/ShortCircuitInterceptor/circuits?folder={toFolder}
```
And the Short Circuit will create the specified folder in the folder used to store the message logs, and will save the cache into it,
one file for every complete cache entry.
NOTE: Only such cached objects will be saved where the response is cached properly. Entries without proper response will be ignored.

The response to save request is the following
```
{
  "resultsSuccess": "Map saved as: messages/{toFolder}/sc0_*.json files"
}
```
As you see, the cache is saved to "messages/{toFolder}" folder in files, by using the "sc0_*.json" pattern.

If you repeat the save request, the plugin will save the cached massages again, by using different names.

Load a cache from a folder
--------------------------
To load a Short Circuit cache, just specify a folder that contains Short Circuit files in the following form:
```
GET http://localhost:1234/config/public/services/ShortCircuitInterceptor/circuits?folder={fromFolder}
```
NOTE: This load does not clean up the exiting cache, rather adds new entries to the cache.
In case a cache entry already exists, it will be overwritten. If you need nothing else just the loaded files in the cache, clean-up the cache first.
